///////////////////////////////////////////////////////////////////////////////
// Name               : ParameterFormula.h
// Purpose            : Store a parameter with a formula
// Thread Safe        : No
// Platform dependent : No
// Compiler Options   : -lm
// Author             : Tobias Schaefer
// Created            : 09.11.2024
// Copyright          : (C) 2024 Tobias Schaefer <tobiassch@users.sourceforge.net>
// Licence            : GNU General Public License version 3.0 (GPLv3)
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef SRC_PROJECT_PARAMETERFORMULA_H_
#define SRC_PROJECT_PARAMETERFORMULA_H_

/** \class ParameterFormula
 * 	\code #include "ParameterFormula.h"\endcode
 * 	\ingroup project
 * \brief Parameter with the capability of keeping a separate formula and value.
 *
 * Stores formula, value, unit, description and has modification-tracking.
 *
 * As this class is derived from the MathParser::Variable, it gets all
 * functions to access the value and Unit from there.
 *
 * \todo Remove the error mechanism and only rely on Exceptions.
 */

#include "Parameter.h"
#include "../math/MathParser.h"

#include <map>
#include <string>

class ParameterFormula: public Parameter {
	friend class ParameterEvaluator;
public:
	ParameterFormula() = delete;
	explicit ParameterFormula(const std::string &name,
			const std::string &formula = std::string(""),
			const std::string &description = std::string(""), const size_t id =
					(size_t) -1, const size_t group = (size_t) -1);
	virtual ~ParameterFormula() = default;

	/**\brief Initialize the parser and parse the formula
	 *
	 * Machine code for the virtual machine is generated. This generation can
	 * (and will) throw a lot as the formula is provided by the user.
	 */
	void Init();

	/**\brief Calculates the value from the formula
	 *
	 * The formula and the variables in the MathParser are used to calculate
	 * the value.
	 *
	 * \return Calculated value as double value.
	 */
	double Calculate();

	/**\brief Setter for the formula.
	 *
	 * When setting a new formula the formula is checked against the old
	 * formula. Afterwards the formula is parsed and machine code for the
	 * virtual machine is generated. This generation can (and will) throw a lot
	 * as the formula is provided by the user.
	 */
	void SetString(const std::string &newFormula) override;

	/**\brief Getter for the current formula.
	 *
	 * Retrieves the formula for display purposes.
	 */
	std::string GetString() const override;

protected:

	/**\brief The formula that is evaluated.
	 *
	 * The main input for the parameter. Even if the parameter is only one
	 * single number, it is put into this formula as text.
	 */
	std::string formula;

	/**\brief MathParser used for evaluation.
	 *
	 * Each parameter has its own math-parser. The parser converts the formula
	 * given into instructions for its virtual machine and stores these.
	 *
	 * Later the formula is evaluated by running the virtual machine in the
	 * parser and returning the value and Unit of the result.
	 */
	MathParser parser;

	/**\brief indicates a parameter from the base group.
	 *
	 * This parameter is a base parameter, even if there are variants, it is
	 * used by all of them.
	 *
	 * If a parameter is created in the global group it is marked base, even
	 * if the group might change later on (-> parameter splitting for
	 * evaluation).
	 */
	bool base = true;

	/**\brief Indicates a parameter, that was for calculation support.
	 *
	 * Automatically generated parameter, to split base parameter. It was added
	 * to make the calculation of variants correct. These extra parameter should
	 * not be used directly as they might be deleted and regenerated by the
	 * ParameterCollection.
	 */
	bool extra = false;

	/**\brief Indicates a global parameter, that might not be the same for every variant.
	 *
	 * Flag set during the ParameterCollection::Update function.
	 *
	 * Indicates that a parameter in the global class can change for different
	 * variants. This happens, if a global variable uses a value from a variant
	 * for calculating its value. In this case the value could be different
	 * depending on the variant calculated.
	 *
	 * The values in the variants will be correct nontheless. See explanations
	 * in the ParameterCollection.
	 */
	bool unstable = false;

public:
	bool errorFlag = false; //!< \b True, if an error occurred during evaluation of the formula.
	std::string errorStr; //!< If an error occurred this contains the error otherwise empty.
};

#endif /* SRC_PROJECT_PARAMETERFORMULA_H_ */
